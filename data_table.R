
###################################################################################################
#datatable intro
###################################################################################################

#creating data.table
sales = data.table(
  state = c("MP","MP","MP","MP","Maharashtra","Maharashtra","Maharashtra"),
  city = c("Indore","Bhopal","Jabalpur","Gwalior","Mumbai","Pune","Nagpur"),
  sales = c(500, 800, 400, 1200, 1800, 1500, 1600)
)

#converting from existing data
#for data.frame or lists
sales = setDT(df_name)

#for other structures
sales = as.data.table(name)

#directly reading from file
#fread directly reads into data.table
sales = fread("filename.csv")

#checking default number of rows to print
getOption("datatable.print.nrows")
#when the number of rows exceeds this number, it will print only the top 5 and bottom 5 rows

#general syntax
DT[i,j,by]
#where
#i => where / order by
#j => select / update / expressions i.e. computing on columns
#by => group by
#read as take DT, subset/reorder rows using i, then calculate j, grouped by "by"

#subset rows
sales[state == "MP" & city == "Indore"]

#select top 2 rows
sales[1:2]

#sort data
sales[order(state, -city)]

#select column but return it as vector
sales[, state]

#select column but return it as data.table
sales[, list(state)] 
#or
sales[, .(state)]
#.() is an alias to list(). Both are same

#select multiple columns
sales[, .(state, city)]

#renaming columns while selecting
sales[, .(states = state, cities = city)]

#counting where sales < 800
sales[, sum(sales < 800)]

#aggregations
sales[state == "MP", .(mean_sales = mean(sales))]

#count number of cities in state MP
sales[state == "MP", length(sales)]
#or
sales[state == "MP", .N]

#selecting columns by writing column names explicitly
sales[, c("state","city")]

#if we have stored the desired columns in a character vector
#then use the ".." prefix or use the "with" argument
select_cols <- c("state","city")
sales[, ..select_cols]
#or
sales[, select_cols, with = FALSE]
#setting "with = FALSE" disables the ability to refer to columns as if they are variables,
#thereby restoring the "data.frame" mode

#deselect columns using "-" or "!"
sales[, !c("state","city")]
#or
sales[, -c("state","city")]

#we can also specify start and end cols to select / deselect
sales[, state:city]
sales[, -(state:city)]

#grouping using by
#number of rows in each state
sales[, .(.N), by = .(state)]
#or using a character vector in "by"
sales[, .(.N), by = "state"]
#the original order of grouping variables is preserved in the result
#if there's only one column or expression in "j" and "by"
#then we can ignore the ".()" notation
sales[, .N, by = state]

#grouping by more variables
sales[state == "MP", .N, by = .(state, city)]

sales[state == "MP", .(sum(sales), mean(sales)), by = state]

#using "keyby" for sorting based on grouped variables
sales[, .(city, rank(-sales)), keyby = state]
#this will sort the output based on "keyby"

#replacing variables
sales[state == "MP", c("state")] = "Mp"

#chaining
sales[state == "Mp"][order(city)]
#chaining can be done by DT[...][...][...]
#or
#vertically
#DT[...
#   ][...
#     ]

#expressions in by
sales[, .N, .(state,sales > 1000)]


#multiple columns in j = .SD
#".SD" stands for Subset of Data
#it by itself is a data.table that holds the data for the current group defined using "by"

sales[, print(.SD), by = state]

#".SD" contains all the columns except the grouping columns by default
#it is also generated by preserving the original order

#computing functions on multiple columns
sales[, lapply(.SD, mean), by = .(state, city)]

#computing functions on selected multiple columns
sales[, lapply(.SD, mean), by = state, .SDcols = c("sales")]
#or
sales[, lapply(.SD, mean), by = state, .SDcols = -c("city")]

#subset ".SD" for each group
#return the first 2 rows for each state
sales[, head(.SD, 2), by = state]

DT = data.table(
  ID = c("d","d","e","e","e","f"),
  a = 1:6,
  b = 7:12,
  c = 13:18
)


#concatenate multiple columns for each group
DT[, .(val = c(a,b)), by = ID]
DT[, print(c(a,b)), by = ID] 
#for each group a vector is returned

#concatenate and return as list for each group
DT[, .(val = list(c(a,b))), by = ID]
DT[, print(list(c(a,b))), by = ID] 
#returns a list of lenght 1 for each group, with it 1st element holding vectors


###################################################################################################
#Reference semantics
###################################################################################################




